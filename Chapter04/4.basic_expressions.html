<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Chapter 4. Basic Expressions and Function Writing</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>


<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



</head>

<body>
<h1>Chapter 4. Basic Expressions and Function Writing</h1>

<p>Sunday, October 12, 2014  </p>

<p><strong>NOTICE</strong>: The main references of this material are: </p>

<ul>
<li>i) <a href="http://renkun.me/learnR/">learnR</a>: Chapter 3. Basic Expressions; </li>
<li>ii) <a href="http://cran.r-project.org/doc/manuals/R-lang.pdf">R Language Definition</a>: Chapter 3. Evaluation of Expressions, Chapter 4. Functions. </li>
</ul>

<h2>Introduction</h2>

<p>Expressions and functions play essential roles in R programming, especially when the analytic tasks are too complicated to use several existed functions to complete. In these situations, loops and functions are often used to control the execute procedure. In this chapter we will explore some basic but useful skills in R programming, and we will also have some examples related to finance study to show how to organize your idea, and how to  transform mathematical models to R programs.</p>

<h3>Contents</h3>

<ul>
<li><p>Basic Expressions</p>

<ul>
<li>Assignment</li>
<li>Operators</li>
<li>Conditions</li>
<li>Loop</li>
</ul></li>
<li><p>Function Writing</p>

<ul>
<li>Elements of a Function</li>
<li>Syntax</li>
<li>Arguments</li>
<li>Return</li>
<li>Statements</li>
<li>Advaced Topics</li>
</ul></li>
<li><p>apply() Family </p>

<ul>
<li>Get to Know apply() Family Functions</li>
<li>Looping in apply()</li>
<li>Anonymous Function in *apply()</li>
</ul></li>
<li><p>Applications</p>

<ul>
<li>Fibonacci Sequence</li>
<li>Discrete Markov Chain</li>
<li>Basic Option Pricing Models</li>
<li>Split-Apply-Combine Strategy in Data Manipulation</li>
</ul></li>
</ul>

<h2>Basic Expressions</h2>

<h3>Assignment</h3>

<p>Assignment might be the most fundamental expression in every programming language. An object in R can be imagined as a box, and  we are able to put anything we want into the box by assignment. </p>

<p>We have several choices to perform this assignment. For example, if we want to create a sequence starts from 1 and ends at 5, and assign it to <code>x</code>:</p>

<pre><code class="r">1:5       # it will be displayed in console but stored in nowhere 
</code></pre>

<pre><code>## [1] 1 2 3 4 5
</code></pre>

<pre><code class="r">x &lt;- 1:5  # first way to assign it
1:5 -&gt; x  # second way
x = 1:5   # third way
</code></pre>

<p>We might be familiar with the third way but the most often used is the first one (using <code>&lt;-</code>) in R. </p>

<p>Assignment chain is also allowed in R:</p>

<pre><code class="r">x &lt;- y &lt;- z &lt;- 0
c(x, y, z)
</code></pre>

<pre><code>## [1] 0 0 0
</code></pre>

<p>Notice the expression <code>0</code> is evaluated only once here. To verify how it works, we can change <code>0</code> to a random number generator.</p>

<pre><code class="r">x &lt;- y &lt;- z &lt;- rnorm(1)
c(x, y, z)
</code></pre>

<pre><code>## [1] 0.3446 0.3446 0.3446
</code></pre>

<h3>Operators</h3>

<p><code>+,-,*,/</code> are all operators in R language. There are a number of operators in R. You may refer to <a href="http://cran.r-project.org/doc/manuals/R-lang.pdf">R Language Definition</a> Page 10 to find all of them. Here we divide these operators into three catgories: arithmetic operators,  logical operators and others. We will also use some examples to show how they are used in R.</p>

<h4>Mathematical Operators</h4>

<p>Mathematical operators are easy to understand:</p>

<pre><code class="r">x &lt;- 2
y &lt;- 5
x + y
</code></pre>

<pre><code>## [1] 7
</code></pre>

<pre><code class="r">x - y 
</code></pre>

<pre><code>## [1] -3
</code></pre>

<pre><code class="r">x * y
</code></pre>

<pre><code>## [1] 10
</code></pre>

<pre><code class="r">x / y
</code></pre>

<pre><code>## [1] 0.4
</code></pre>

<pre><code class="r">x ^ y
</code></pre>

<pre><code>## [1] 32
</code></pre>

<pre><code class="r">x : y
</code></pre>

<pre><code>## [1] 2 3 4 5
</code></pre>

<pre><code class="r">y %% x  # modulus 5%%2 = 1
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">y %/% x # interger divide 5%/%2 = 2
</code></pre>

<pre><code>## [1] 2
</code></pre>

<p>Notice, <code>*</code> is different from what we have learned in math class when it is applied to matrices. To perform the so-called &ldquo;matrix product&rdquo;, we should use <code>%*%</code>.</p>

<pre><code class="r">x &lt;- matrix(1:9, nrow=3)
y &lt;- matrix(1:9, nrow=3, byrow=TRUE)
x * y
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]    1    8   21
## [2,]    8   25   48
## [3,]   21   48   81
</code></pre>

<pre><code class="r">x %*% y
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]   66   78   90
## [2,]   78   93  108
## [3,]   90  108  126
</code></pre>

<h4>Logical Operators</h4>

<p>Logical operators, or Boolean operators are used to calculate logical relationships. The first thing we should know is that logical value, which includes <code>TRUE</code> and <code>FALSE</code>, is also a kind of variable. </p>

<pre><code class="r">x &lt;- TRUE
class(x)
</code></pre>

<pre><code>## [1] &quot;logical&quot;
</code></pre>

<p>The simplest situation happens when we want to know whether a statement is true or not. </p>

<pre><code class="r">x &lt;- 1
y &lt;- 2
z &lt;- 2
x &gt; y
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<pre><code class="r">z &gt;= y
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">z == y
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">x == y
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<pre><code class="r">z != y
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<p>These operators are used to compare the values of two variables. </p>

<p>R also provides a useful operator <code>%in%</code> to find if a certain element exist in another object.</p>

<pre><code class="r">y &lt;- c(1, 3, 5, 6)
3 %in% y
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">4 %in% y
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<p>See what happens if we do it this way:</p>

<pre><code class="r">x &lt;- c(1, 2, 4, 6)
y &lt;- c(1, 3, 5, 6)
x %in% y
</code></pre>

<pre><code>## [1]  TRUE FALSE FALSE  TRUE
</code></pre>

<p>Using these operators, we can find if a statement is true or not. However, sometimes we also need to calculate the relationship of two logical values. The basic calculations of two logical values are <code>and</code>, <code>or</code> and <code>not</code>. <code>and</code> and <code>or</code> combines two simple statement into one complex/compound statement, and <code>not</code> reverses the logical value. </p>

<pre><code class="r">x &lt;- TRUE
y &lt;- FALSE
x | y
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">x &amp; y
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<pre><code class="r">!(x) &amp; y
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<pre><code class="r">!(x | y)
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<p>Notice, two operators are provided to calculate <code>and</code>: <code>&amp;</code> and <code>&amp;&amp;</code>. Also two operators for <code>or</code>: <code>|</code> and <code>||</code>. We must be clear about their differences.</p>

<pre><code class="r">x &lt;- c(TRUE, FALSE, TRUE)
y &lt;- c(FALSE, TRUE, TRUE)
x &amp; y
</code></pre>

<pre><code>## [1] FALSE FALSE  TRUE
</code></pre>

<pre><code class="r">x &amp;&amp; y
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<pre><code class="r">x | y
</code></pre>

<pre><code>## [1] TRUE TRUE TRUE
</code></pre>

<pre><code class="r">x || y
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>In R, <code>&amp;</code> and <code>|</code> are called vectorized logical operators, and <code>&amp;&amp;</code> and <code>||</code> are non-vectorized logical operators. Remind this is different with C.</p>

<h4>Other Operators</h4>

<p><code>$</code> and <code>~</code> are also listed as operators. <code>$</code> is used in select objects in a certain environment. <code>~</code> is often used in formulas. We will talk about it in future discussions.</p>

<h3>Conditions</h3>

<p>How to tell my computer I want to execute certain codes only if some conditions are satisfied, and skip those lines when not satisfied? </p>

<pre><code class="r">if( condition ){
  statement
}
</code></pre>

<p>In this code, R will evaluate the condition and test if it is satisfied or not. The statement in bracket will be executed only if <code>condition</code> equals TRUE. </p>

<pre><code class="r">x &lt;- 2
if( x == 1 ){
  test &lt;- 1
}
test
</code></pre>

<p>Here we can find that <code>test</code> is not even existed! The example above also shows a often met mistake. Since we do not have to declare a variable before we use it, which is required in C/Cpp and many other languages, we must be careful about the logic of the program. </p>

<p>We may add <code>else</code> to test further conditions.</p>

<pre><code class="r">if( condition.1 ){
  statement.1
} else if( condition.2 ) {
  statement.2
} else {
  statement.3
}
</code></pre>

<p>For example,</p>

<pre><code class="r">signal &lt;- 1

if( signal == 1 ){
  action &lt;- &quot;Open Long&quot;
} else if( signal == -1 ){
  action &lt;- &quot;Open Short&quot;
} else if( signal == 0 ){
  action &lt;- &quot;Close Position&quot;
} else {
  action &lt;- &quot;Continue&quot;
}

action
</code></pre>

<pre><code>## [1] &quot;Open Long&quot;
</code></pre>

<p>For convenience, if-else sentence can be written in a single line.</p>

<pre><code class="r">if( condition ) statement.1 else statement.2
</code></pre>

<p>Function <code>ifelse()</code> is very useful when the statement line is short:</p>

<pre><code class="r">x &lt;- 3
y &lt;- ifelse(x == 2, x^2, x*3)
y
</code></pre>

<pre><code>## [1] 9
</code></pre>

<p>Besides the logical operators we have mentioned, function <code>any()</code> and <code>all()</code> are also often used when there are a lot of conditions to test. </p>

<pre><code class="r">x &lt;- c(1, 3, 5, 2)
x &gt; 2
</code></pre>

<pre><code>## [1] FALSE  TRUE  TRUE FALSE
</code></pre>

<pre><code class="r">x == 3
</code></pre>

<pre><code>## [1] FALSE  TRUE FALSE FALSE
</code></pre>

<pre><code class="r">all( x &gt; 2 )
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<pre><code class="r">any( x == 3)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p><code>switch()</code> is also used to deals with conditions, but in a different way.</p>

<pre><code class="r">switch(1,&quot;x&quot;,&quot;y&quot;) # the n-th argument will be returned.
</code></pre>

<pre><code>## [1] &quot;x&quot;
</code></pre>

<pre><code class="r">switch(2,&quot;x&quot;,&quot;y&quot;)
</code></pre>

<pre><code>## [1] &quot;y&quot;
</code></pre>

<p>If the number is larger than the number of followed arguments, a <code>NULL</code> will be returned.</p>

<pre><code class="r">switch(3,&quot;x&quot;,&quot;y&quot;)
</code></pre>

<p><code>switch()</code> performs differently when the input is a character.</p>

<pre><code class="r">switch(&quot;a&quot;,a=1,b=2)
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">switch(&quot;b&quot;,a=1,b=2)
</code></pre>

<pre><code>## [1] 2
</code></pre>

<pre><code class="r">switch(&quot;c&quot;,a=1,b=2)
</code></pre>

<p>Note that <code>switch()</code> might be helpful to write a user-friendly function, since various situations might happen and we must test what the user really want to do.</p>

<h3>Loop</h3>

<p>Computers does not know how to prove a new mathematical theorem, but knows how to finish simple calculations thousands times within seconds. </p>

<p>By looping, we divide a complicated task into repeated calculations. For example, using <code>for-looping</code>:</p>

<pre><code class="r">y &lt;- 0
for( i in 1:100 ){
  y &lt;- y+i
}

y
</code></pre>

<pre><code>## [1] 5050
</code></pre>

<p>From this example you may guess how <code>for-loop</code> works in R. General syntax for <code>for-loop</code> is</p>

<pre><code class="r">for( iterator in vector ){
  statement to be evaluated each time
}
</code></pre>

<p>Notice 1, iterator is changing during the looping, and will still exist after loop (a kind of side effect).</p>

<p>Notice 2, we usually use vectors for looping, but <code>list</code>, <code>data.frame</code> can also be used for looping.</p>

<pre><code class="r">df &lt;- data.frame(a=rnorm(100, mean=1), b=rnorm(100, mean=0), c=rnorm(100, mean=3) )
for( var in df ){
  message( mean(var) )
}
</code></pre>

<pre><code>## 1.05562676940501
## -0.0232045008341926
## 2.96891539726596
</code></pre>

<pre><code class="r">lists &lt;- list(a=rnorm(100, mean=1), b=rnorm(50, mean=0), c=rnorm(800, mean=3))
for( x in lists ){
  message( mean(x) )
}
</code></pre>

<pre><code>## 1.03320320171668
## 0.139780970498133
## 3.00287710336265
</code></pre>

<p><code>next</code> and <code>break</code> gives us further controls over the program. <code>next</code> skips following lines, and <code>break</code> stops the current level loop.</p>

<pre><code class="r">s &lt;- 0
for( i in 1:10 ){
  if( i == 3 ) next
  if( i == 6 ) break
  s &lt;- s+i
}

s
</code></pre>

<pre><code>## [1] 12
</code></pre>

<p>Notice the positions of <code>next</code> and <code>break</code> lines will change the result.</p>

<pre><code class="r">s &lt;- 0
for( i in 1:10 ){
  if( i == 6 ) break
  s &lt;- s+i
  if( i == 3 ) next
}

s
</code></pre>

<pre><code>## [1] 15
</code></pre>

<p><code>repeat</code> and <code>while</code> are also used for looping. </p>

<pre><code class="r">repeat statement
</code></pre>

<p>Remember you must give termination condition and use <code>break</code> to stop the loop, and also the termination condition must be satisfied in future time, or you will never get out the loop! Actually sometimes it not easy to know whether the terminal condition will be satisfied in the &ldquo;future&rdquo;, and for this reason <code>repeat-loop</code> is seldom used in practice.</p>

<p>The last way to loop is <code>while-loop</code>.</p>

<pre><code class="r">while( condition ){
  statement
}
</code></pre>

<p><code>while-loop</code> is very similar to <code>repeat-loop</code>, but gives the termination condition more explicitly. In <code>while-loop</code>, the statement will be evaluated only if <code>condition</code> equals <code>TRUE</code>.</p>

<p>For the same reason, we must be careful about if the terminal condition can be satisfied.</p>

<pre><code class="r">s &lt;- 0
i &lt;- 1  # remember to creat iterator by yourself.
while( s &lt; 1000 ){
  s &lt;- s + i
  i &lt;- i + 1  # remember to renew your interator.
}

s
</code></pre>

<pre><code>## [1] 1035
</code></pre>

<p>However, we are still able to use <code>for-loop</code> to do the same thing.</p>

<pre><code class="r">s &lt;- 0
for( i in 1:1e8 ){
  if( s+i &gt;= 100 ) break
  s &lt;- s + i
}

s
</code></pre>

<pre><code>## [1] 91
</code></pre>

<h2>Function Writing</h2>

<h3>Elements of A Function</h3>

<p>Before starting learning how to write a function in R, we firstly consider what a function really is. </p>

<p>In mathematics, a function is a kind of rule. When we put a number <code>x</code> into the function, it will be mapped to another number <code>y</code>. It seems like a black-box if we ignore how <code>x</code> is processed in it and just focus on its input and output. </p>

<p>In any kind of programming language, function works in the same way. Consider function <code>factorial()</code>:</p>

<pre><code class="r">factorial(5)
</code></pre>

<pre><code>## [1] 120
</code></pre>

<p>This calculates \( n\times(n-1)\times(n-2)\dots\times1 \). Here the input number is <code>5</code>, the output number is <code>120</code>. And how the input number <code>5</code> is processed is given by the equation.</p>

<p>So we can divide a function into three parts:</p>

<ul>
<li>1. The input (<code>5</code>)</li>
<li>2. The output (<code>120</code>)</li>
<li>3. How the input is procced into the output. ( \( n\times(n-1)\times(n-2)\dots\times1 \))</li>
</ul>

<p>In R (and in any other programming language), we define them as:</p>

<ul>
<li>1. Arguments</li>
<li>2. Return</li>
<li>3. Statements</li>
</ul>

<p>If we want to write a function, we must be clear about all these three things. Ask yourself what are given, what you want, and how to connect these two things.</p>

<h3>Syntax</h3>

<p>Different language has different syntax for writing functions. In R, we create a function in this way:</p>

<pre><code class="r">function.name &lt;- function( argument.1, argument.2 ){
  statements...
  return(result)
}
</code></pre>

<p>Here we just give a simple example:</p>

<pre><code class="r">myfun &lt;- function(x, a, b){
  y &lt;- a + b*x
  return(y)
}
</code></pre>

<p>Notice, a function is also a kind of object in R:</p>

<pre><code class="r">class(myfun)
</code></pre>

<pre><code>## [1] &quot;function&quot;
</code></pre>

<p>When the function is created, we can use it just as any existed functions in R.</p>

<pre><code class="r">myfun(x=3, a=1, b=2)
</code></pre>

<pre><code>## [1] 7
</code></pre>

<h3>Arguments</h3>

<h4>Argument Matching</h4>

<p>All of the following are allowed in R:</p>

<pre><code class="r">myfun(x=3, a=1, b=2)
</code></pre>

<pre><code>## [1] 7
</code></pre>

<pre><code class="r">myfun(a=1, b=2, x=3)
</code></pre>

<pre><code>## [1] 7
</code></pre>

<pre><code class="r">myfun(3, 1, 2)
</code></pre>

<pre><code>## [1] 7
</code></pre>

<pre><code class="r">myfun(x=3, 1, 2)
</code></pre>

<pre><code>## [1] 7
</code></pre>

<p>The first two examples are called &ldquo;exact matching&rdquo;, since they give the exact names of all arguments.</p>

<p>The second way is called &ldquo;positional matching&rdquo;. </p>

<p>Also, we can use &ldquo;partial matching&rdquo; sometimes. (See <a href="http://cran.r-project.org/doc/manuals/R-lang.pdf">R Language Definition</a>, Page 23, 4.3.2)</p>

<h4>Default Value</h4>

<p>We can set default values to the function:</p>

<pre><code class="r">myfun &lt;- function(x, a=1, b=2){
  y &lt;- a + b*x
  return(y)
}
</code></pre>

<p>We have different choices to call the function <code>myfun()</code>:</p>

<pre><code class="r">myfun(1)
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">myfun(x=1, a=2, b=3)
</code></pre>

<pre><code>## [1] 5
</code></pre>

<pre><code class="r">myfun(1, a=3)
</code></pre>

<pre><code>## [1] 5
</code></pre>

<p>( This actually used a mechanism inside R called &ldquo;lazy evaluation&rdquo;. To know more, read: <a href="http://renkun.me/learnR/inside-r/lazy-evaluation.html">Lazy Evaluation</a> )</p>

<h3>Return</h3>

<h4>Using <code>return()</code></h4>

<p>In the examples above, we used <code>return()</code> to tell R which object to be returned when we call the function. However, <code>return()</code> is not a must in a function. R will return the last shown object.</p>

<pre><code class="r">myfun &lt;- function(x, a, b){
  y &lt;- a + b*x
}
</code></pre>

<pre><code class="r">myfun(3, 1, 2)

z &lt;- myfun(3, 1, 2)
z
</code></pre>

<pre><code>## [1] 7
</code></pre>

<p>Notice, at this time the result will not be shown, but it can still be assigned to another object.</p>

<p>We can also simplify the function in this way:</p>

<pre><code class="r">myfun &lt;- function(x, a, b) y &lt;- a + b*x

z &lt;- myfun(3, 1, 2)
z
</code></pre>

<pre><code>## [1] 7
</code></pre>

<p>However, we usually recommend to explicitly write <code>return()</code> when we are not very familiar with R, in order to make the codes more readable.</p>

<h4>What if we do not care about the return?</h4>

<p>In some situations, we do not care about what its return is. We use these functions to plot, to write data, to edit a data frame directly and so on. These actions are also allowed in R, and they do not need a specific return. </p>

<p>For example, we want a function to plot <code>n</code> random numbers:</p>

<pre><code class="r">plot.rnorm &lt;- function(n){
  rand &lt;- rnorm(n)
  plot(rand)
}
</code></pre>

<p>When we call this function, it will plot directly.</p>

<pre><code class="r">plot.rnorm(100)
</code></pre>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfgAAAH4CAMAAACR9g9NAAAAclBMVEX9/v0AAAAAADkAAGUAOTkAOWUAOY8AZrU5AAA5ADk5AGU5OWU5OY85j9plAABlADllAGVlOQBlOY9lZmVltf2POQCPOTmPZgCPtY+P29qP2/21ZgC1/rW1/v3ajzna/tra/v39tWX924/9/rX9/tr9/v251xIjAAAAJnRSTlP/////////////////////////////////////////////////AKd6gbwAAAAJcEhZcwAACxIAAAsSAdLdfvwAAAyHSURBVHic7Z0Ld9s2EkarpBun3thJd+W0a6+1sWT9/7+4pB62bOsBkANiBt+9J2l6jq0hwAvMgC/xtzVI8lvtBkAdEC8K4kVBvCiIFwXxoiBeFMSLgnhREC8K4kVBvCiIFwXxoiBeFMSLgnhREC8K4kVBvCiIFwXxoiBeFMSLgnhREC8K4kVBvCiIFwXxoiBeFMSLgnhREC8K4kVBvCiIFwXxoiBeFMSLgnhREC8K4kVBvCiIFwXxoiBeFMSLgnhREC8K4kVBvCiIFwXxoiBeFMSLgnhREC/KGPEz8ExB8SM+C6VBvCiIFwXxoiBeFMSLgnhREC8K4kVBvCiIt+TimVA/IN6Q2TpOrxFvCOJTQjcI4lNCtwg1PiE0VAXxoiBeFMSLgnhREC8K4kVBvCiIFwXxoiBeFMSLgnhREC8K4kVBvCiIFwXxoiBeFMSLgnhREC8K4kVBvCiIFwXxoiBeFMSLgnhREC8K4kVBvCiIFwXxoiBelNHil19nn+7X69WPx8zQUJWx4p/v5t3fG8RHY6z4rfCHqwPxia+7gapYzPiOxe/XzPhQjK7xq9ub/p/FZ8SHglW9KIgXBfH1qLr+RXw16n7lMeKrgXhREK8KNR6mHwSId8H0aR/xLkC8KIhXhRoP04B4URAvCuKzaOe+IsTnkLr4DjA+EJ9Dovi6Z+HTQHwOiDcIHZK0HI54Vajx4BXEt0RGpkF8Q+SsLRDfEIgXBfFT42UVT42flgjH7e9BvAGIzwndEIjPCd0SXmp8BogXBfGiIF4UxIuCeFEQLwriRUG8KIgXBfET4+UkH+Knxc1pfafivcwLcxB/8aMudo85bnqG+InxkssQL4pP8W7mRbs4FQ+laUs8iSKZpsSzNEgH8aIgXoT3VbAp8dT4k3yYE97Eo64M3sWTrAuBeFWc13gj8RSMizgTb6MsQN6oPjS9iTfBv/j6LUR8Feq3sEnx9RPpJRCvSvWhiXhREC8K4odSPVmPo6b40Luu/vJsHGPFr25nWz4/voTck7DpuLsudusNZvzz3c2w0MF3XezWW6T61ff7QaGj77rQhYoaL8tk4g8tmxufdAhNPV7LbG8q8Yd53TzHT1o0pq5QhbaHeNcbK7c9xFttrFQFCC6++RpfbvDFrvHNc068x8MXxBtxRrzLExaIt+L0tEa8KIhXhRoPbkC8KIgfi8c8ngDiR+Jy5ZYA4keC+NzQjYD43NCtQI3PDB2OoIZPgPhUBuR0z0MF8anki3dd/j2I9zwxXkG8Ueg3v+d2/xyQPT5dd8yx+PGJoHYqqb39c/gVP36+uJ5xRUkYcQ7EF7uJTVZ8Ssc9iD/9ccQPIrb4Bmp8LYKLh8EEqfFQAcSL0rz4Y1lPtfYf0rr4Y+sc2dX+IQHFZ81XxJ8gnvg8befES2f81sWfqfHaE7958RMEqseInBVPvFmGji9+TA8CijcjfI1HvCiIV0WrxoMFiBcF8dEZmO4RHwbbO9QQHwXje1JriQ9/DD05bYiPf9Zsck7tslg1vhHxDr5KdXC08z/uxR957czo0G2IH5xmHdS5tBn/0L93ZnFlGNpD3/ek3JNquaI+/Fi1/ZAkfvXj8eW/ZqHdkKDPdmF18LF6mS9J/PZNU4svvyxDu2G4+IHzNY74znzXxcxM71D84IRt7Oe1Hd7Flwg9PSPmbbFS7LvGFwk9PW0cShiRJv7J+nCuCog/IG1Vfzu3D10BT8eQpbnU14zDuexND/gMrG3G58XslnECZ8i2IR+TimQjfnfSNnqND4Ij8cO3DfnYrEFNavzATY/47JDNNbNym6QnaeIX/lM9x2p5pNX47/dPV7ZX58xBfB6ph3PbP0d+Y/n1VDZAvGfSrs79vO/+LK+PiH++257befp46Y4a75m0Gt85f5rNjh3M79PAQTqY7bFqoz8a6NzYVb2fGT8hLZSV0adsT5/csd41J6ZZhdknI74r8Pahh4Szu/2pRFNCEeeUrSPx1PgxoYeE8yK+AeKId1Tjh+KpqYHEh8dVckL8dCDeBE95Mw3EW+BqLybiaawiXhTEF8LT7D5GWPHO96z3cRlYvG/ciD81PxBfBi/iT7YD8YVwUokQv8eJkGOUaBridySm4BrDo0x18F7jp9rTaXu3zrXeSTfqRPxknUb8wdbOYC++1DvDU0lKLXXW5H3TJqsxU4sPcjtFrSXghBPg/I+nEu95sT0leuJhQ7vi5aZ2Zn+brfFquM1wquJ9nTeogKh4Z+cNKoD40ltysKY5+mLl8x9xLv70q6IvfXDte2CacrSzocUf65HjqzC1QLwEH4c04hU4uk+o8e2TOvBji4cPRBEvPj8LkLhHK4t3WZElBiPiP+CxTfYg/gNe2lQ28Tiv8Tadz4uyF1854xcef7XFv/lA2qmHQQ3JMj97cT9628MZ1uqs8GeYUvyRntYRb7nt4WRuP3ucnP8x4usxrEDl/P4ZKouvUuNttz0VgcUH29PeiFvjYUoQLwriRUG8KIgXBfEtMOB4CPGhsHvIHPGROHH9CPHDiXHyaGf4vWjED6b6ifk0Toinxg8miHjDK8YxxZsn5qri83tj0P+Q4gtoqljj6ww6xFcH8VmRET9+q2eoIv5y2rVLzB4O46q0waH4KWdAW7kjB8Qj/hiIbxWH4s/VPPsD+MsBPSwD7PEo/nzIqS00mhQQ73Gbrxsvlm3Git+9Wv7Yy+UR73nbo2f8893NsNCDqPLKkCbP5o5P9avv9+9C7hneKtjiWvzQ0JCA3xo/PDRUxUb84lidR7xnEC8K4kWhxouCeFEQLwriRUG8KIgXBfGiID4cRl8Bd/7HiHeH0RU7xEcD8bEwu8CK+FAY3lKxG0IjRxLip8H8XpqxAYOID38jF+IHh4pu3njoIl4ViRqPeHNiiI9f490RRLwa5Qc64t/y/jsj62SaCUob4t/wbo/XWlsg3o60uYv4Hc2IT9yVTsRT481IVeijxk8A4kVREd/w3B2GjHh4C+JFQbwoiBcF8aIgXpRJxXNI5YcpxXMSxRGIF6VZ8ZSV87Ra48kuF2h1VY/4CyBelFbFU+Mv0Kx4OA/iQ2CfvxAfgQIrFsRHAPGiDBR/rkAgPgSDavzZ4YL4dkG8KIhXhRoPH0D8K1JneRH/gtZ1HcS/gPgDEN8qiH+FGv+KlHgpEC8K4kVBvCijxS+/zj7dr9erH4+ZoaEqY8U/3827vzeIj8ZY8VvhD1eID4bFjO9Y/H6N+FCMrvGr28274xefX8TP9oxsGpSEVb0oiBfFRvziJj80VAXxoiBeFGq8KIgXBfGiIF4UxIuCeFEQLwrirQlydQrxxkS5Ox/xxiA+RPftQXyI7heAGh+i/7IgXhTEi4J4URAvCuJFCSA+yPFRMPyLj3JGJBiIFwXxovgXT40vQgDxUALEi4J4URAvCuJFQbwoiBcF8aIgXhTEi4J4UUqKB8+UE384BmzClIhG046C+IrREF8yGk07CuIrRkN8yWg07SiIrxgN8SWj0bSjGImHaCBeFMSLgnhREC8K4kVBvCiIFwXxoiBeFAvxq9vZl18GcdabV1fP5nYRN+9HNQr2fLd9q7ZJtK6f/Zs7TYItr18jpQc0EN/v3cXV+Dgdq+/36+Uf92YRF7O5WfMe5uunL79sovX9XBgFe+qH0C5SRkAD8f17ppcfXzk8hKe+0Q9zq4jLf/45t2re7m3aNtGW3371kSyCPXz6u4uwi5QR0ED8phfdEDaiC2UU8fnnf7oZYBRs+e2vPtXbRNvNeJtgveldpIyABuK7BGgo/vnuxiri4qZPfUbBll83Y8go2rYW2wTrxe8iZQT0NuM3Ly03mgnfNkXUbMbnzqlzwf64Xz99fgw+4w1r/GZeWUVcbO4uv7Gq8f/a7FObaLuZabRgqFXj++RstKrfereL2M94q2AP820OsYi2m/FGwa4f953MCOjrOH47Secuj+O7MGaH3t0xmN1JgWrH8RARxIuCeFEQLwriRUG8KIgXBfGiIF4UxIuCeFEQLwriRUG8KIgXBfGiIF4UxIuCeFEQL4qy+Lc3Im9uzNQB8XsQL0Mnvn8ibvdc9j/+nO9uoX4we07AMeriv26f1OtcP3UDYKt89eO/P2weDHKMuvjrl0ePulTfP3bW/+9idlO7bcVB/P6f/rn829nmCZf+CafWQfzhjN9l+Id/N1/iEb99vPS1xj/131fwv5/NT3nE75423a/qP93vv02hbZTFS4N4URAvCuJFQbwoiBcF8aIgXhTEi4J4URAvCuJFQbwoiBcF8aIgXhTEi4J4Uf4Povmii+Tu+0gAAAAASUVORK5CYII=" alt="plot of chunk unnamed-chunk-36"/> </p>

<p>Still, we want to know what if we assign it to an object.</p>

<pre><code class="r">test &lt;- plot.rnorm(100)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-37"/> </p>

<pre><code class="r">test
</code></pre>

<pre><code>## NULL
</code></pre>

<p>Think about why. The reason is <code>plot(rand)</code> is the last line in the function, and <code>plot()</code> function returns the <code>NULL</code>! </p>

<h3>Statements</h3>

<p>There is no more thing to tell about statements, though these statements are the main body of a function. The reason is, you are writing in the same way as you are writing an R script.</p>

<h3>Further Topics</h3>

<p>Here we just list some of the further topics of R programming, most of which will tell you the underlying mechanism of R. Though your codes still works if you have no idea about these stuffs, they will become important when you get more and more familiar with R.</p>

<ul>
<li>Recycling Rules (See <a href="http://cran.r-project.org/doc/manuals/R-lang.pdf">R Language Definition</a>, Page 15, 3.3.1)</li>
<li>Copy on Write</li>
<li>Lazy Evaluation (<a href="http://renkun.me/learnR/inside-r/lazy-evaluation.html">learnR</a>, 8.1)</li>
<li>Scoping (See <a href="http://cran.r-project.org/doc/manuals/R-lang.pdf">R Language Definition</a>, Page 20, 3.5)</li>
<li>Debugging (See <a href="http://cran.r-project.org/doc/manuals/R-lang.pdf">R Language Definition</a>, Page 40, 9)</li>
<li>dot-dot-dot</li>
</ul>

<h2>apply() Family</h2>

<h3>Get to Know apply() Family Functions</h3>

<h4><code>apply()</code></h4>

<p><code>apply()</code> returns a vector or array or list of values obtained by applying a function to margins of an array or matrix. It is useful to deal with matrix and other high dimensional data. (From R base)</p>

<pre><code class="r">x &lt;- cbind(x1 = 3, x2 = c(4:1, 2:5))
dimnames(x)[[1]] &lt;- letters[1:8]
apply(x, 2, mean, trim = .2)
</code></pre>

<pre><code>## x1 x2 
##  3  3
</code></pre>

<pre><code class="r">col.sums &lt;- apply(x, 2, sum)
row.sums &lt;- apply(x, 1, sum)
</code></pre>

<h4><code>tapply()</code></h4>

<p>Apply a function to each cell of a ragged array, that is to each (non-empty) group of values given by a unique combination of the levels of certain factors.</p>

<pre><code class="r">test &lt;- data.frame(x=rnorm(1000, mean=2), 
                   y=rpois(1000, lambda=3), 
                   g=rep(LETTERS[1:5], 200))

tapply(test$x, test$g, mean)
</code></pre>

<pre><code>##     A     B     C     D     E 
## 2.005 2.068 1.998 1.952 2.013
</code></pre>

<pre><code class="r">tapply(test$y, test$g, mean)
</code></pre>

<pre><code>##    A    B    C    D    E 
## 3.04 3.16 2.94 3.16 3.11
</code></pre>

<h4><code>lapply()</code></h4>

<p><code>lapply()</code> returns a list of the same length as X, each element of which is the result of applying FUN to the corresponding element of X.</p>

<pre><code class="r">x &lt;- list(a = 1:10, 
          beta = exp(-3:3), 
          logic = c(TRUE,FALSE,FALSE,TRUE))

lapply(x, mean)
</code></pre>

<pre><code>## $a
## [1] 5.5
## 
## $beta
## [1] 4.535
## 
## $logic
## [1] 0.5
</code></pre>

<pre><code class="r">lapply(x, quantile)
</code></pre>

<pre><code>## $a
##    0%   25%   50%   75%  100% 
##  1.00  3.25  5.50  7.75 10.00 
## 
## $beta
##       0%      25%      50%      75%     100% 
##  0.04979  0.25161  1.00000  5.05367 20.08554 
## 
## $logic
##   0%  25%  50%  75% 100% 
##  0.0  0.0  0.5  1.0  1.0
</code></pre>

<pre><code class="r">lapply(x, quantile, probs = 1:4/5)
</code></pre>

<pre><code>## $a
## 20% 40% 60% 80% 
## 2.8 4.6 6.4 8.2 
## 
## $beta
##    20%    40%    60%    80% 
## 0.1818 0.6207 2.0310 6.4549 
## 
## $logic
## 20% 40% 60% 80% 
## 0.0 0.2 0.8 1.0
</code></pre>

<h4><code>sapply()</code></h4>

<pre><code class="r">x &lt;- list(a = 1:10, 
          beta = exp(-3:3), 
          logic = c(TRUE,FALSE,FALSE,TRUE))

sapply(x, mean)
</code></pre>

<pre><code>##     a  beta logic 
## 5.500 4.535 0.500
</code></pre>

<pre><code class="r">sapply(x, quantile)
</code></pre>

<pre><code>##          a     beta logic
## 0%    1.00  0.04979   0.0
## 25%   3.25  0.25161   0.0
## 50%   5.50  1.00000   0.5
## 75%   7.75  5.05367   1.0
## 100% 10.00 20.08554   1.0
</code></pre>

<h3>Anonymous Function in <code>*apply()</code></h3>

<p>In some cases, R also allows anonymous functions. This is useful when you only want to use a function once.</p>

<pre><code class="r">(function(x) 2*x)(2)
</code></pre>

<pre><code>## [1] 4
</code></pre>

<p>Anonymous is very often used in <code>*apply()</code> family: We use <code>*apply()</code> to loop, and write anonymous functions in it.</p>

<pre><code class="r">sapply(1:100, FUN = function(i){
  sim &lt;- rnorm(100, mean=i)
  return(mean(sim))
})
</code></pre>

<pre><code>##   [1]   1.158   1.891   3.183   4.038   5.163   5.923   7.119   7.913
##   [9]   8.895  10.072  11.014  12.021  12.846  13.975  14.980  16.080
##  [17]  16.998  18.043  19.170  20.094  20.920  21.865  22.942  24.146
##  [25]  24.708  25.950  27.004  27.763  28.953  30.050  30.920  31.992
##  [33]  32.906  34.049  34.941  35.876  37.087  38.106  38.974  39.936
##  [41]  40.822  41.934  42.907  43.959  44.877  46.129  46.981  47.996
##  [49]  48.969  50.200  50.888  52.112  53.102  53.958  54.944  55.962
##  [57]  56.834  58.219  59.035  60.074  60.932  61.996  63.108  64.158
##  [65]  64.994  65.941  66.956  68.004  69.065  69.859  71.073  71.994
##  [73]  73.061  74.123  75.015  76.055  77.075  78.100  78.947  80.103
##  [81]  80.863  81.907  83.059  83.886  84.828  86.004  86.980  88.119
##  [89]  88.964  90.027  90.928  92.013  92.905  94.071  94.906  96.097
##  [97]  96.939  98.019  99.112 100.063
</code></pre>

<pre><code class="r">ul &lt;- sapply(LETTERS, function(L){
  c(L, tolower(L))  
})

t(ul)
</code></pre>

<pre><code>##   [,1] [,2]
## A &quot;A&quot;  &quot;a&quot; 
## B &quot;B&quot;  &quot;b&quot; 
## C &quot;C&quot;  &quot;c&quot; 
## D &quot;D&quot;  &quot;d&quot; 
## E &quot;E&quot;  &quot;e&quot; 
## F &quot;F&quot;  &quot;f&quot; 
## G &quot;G&quot;  &quot;g&quot; 
## H &quot;H&quot;  &quot;h&quot; 
## I &quot;I&quot;  &quot;i&quot; 
## J &quot;J&quot;  &quot;j&quot; 
## K &quot;K&quot;  &quot;k&quot; 
## L &quot;L&quot;  &quot;l&quot; 
## M &quot;M&quot;  &quot;m&quot; 
## N &quot;N&quot;  &quot;n&quot; 
## O &quot;O&quot;  &quot;o&quot; 
## P &quot;P&quot;  &quot;p&quot; 
## Q &quot;Q&quot;  &quot;q&quot; 
## R &quot;R&quot;  &quot;r&quot; 
## S &quot;S&quot;  &quot;s&quot; 
## T &quot;T&quot;  &quot;t&quot; 
## U &quot;U&quot;  &quot;u&quot; 
## V &quot;V&quot;  &quot;v&quot; 
## W &quot;W&quot;  &quot;w&quot; 
## X &quot;X&quot;  &quot;x&quot; 
## Y &quot;Y&quot;  &quot;y&quot; 
## Z &quot;Z&quot;  &quot;z&quot;
</code></pre>

<h2>Application</h2>

<p>Equipped with the knowledge of operators, conditions and looping, we now come into a new topic: build your own program.</p>

<p>This is a very exiting part because it shows how you can tell your computer to work as you like and finish your tasks. Even the most complicated algorithm is generated from these structures, and you can show how creative you are using these basic tools.</p>

<h3>Fibonacci Sequence</h3>

<p>The generation of Fibonacci sequence is often used as study examples and also used to test the efficiency of a programming language.</p>

<p>In Fibonacci sequence,</p>

<p>\( F_{i}=F_{i-1}+F_{i-2}, i=3, 4, 5, \dots \)</p>

<pre><code class="r">n &lt;- 50
fib &lt;- c(1, 1)

for( i in 3:50 ){
  fib[i] &lt;- fib[i-1] + fib[i-2]
}

fib
</code></pre>

<pre><code>##  [1] 1.000e+00 1.000e+00 2.000e+00 3.000e+00 5.000e+00 8.000e+00 1.300e+01
##  [8] 2.100e+01 3.400e+01 5.500e+01 8.900e+01 1.440e+02 2.330e+02 3.770e+02
## [15] 6.100e+02 9.870e+02 1.597e+03 2.584e+03 4.181e+03 6.765e+03 1.095e+04
## [22] 1.771e+04 2.866e+04 4.637e+04 7.502e+04 1.214e+05 1.964e+05 3.178e+05
## [29] 5.142e+05 8.320e+05 1.346e+06 2.178e+06 3.525e+06 5.703e+06 9.227e+06
## [36] 1.493e+07 2.416e+07 3.909e+07 6.325e+07 1.023e+08 1.656e+08 2.679e+08
## [43] 4.335e+08 7.014e+08 1.135e+09 1.836e+09 2.971e+09 4.808e+09 7.779e+09
## [50] 1.259e+10
</code></pre>

<p>Now, consider to write a function to get a certain element of Fibonacci sequence.</p>

<p>Of course we can still use the method above and modify it as a function. The following codes shows that functions are allowed to call itself and thus able to complete recursive algorithm conveniently.</p>

<pre><code class="r">fib &lt;- function(n){
  if(n == 1 || n == 2){
    fib &lt;- 1
  } else {
    fib &lt;- fib(n-1) + fib(n-2)
  }
  return(fib)
}

fib(10)
</code></pre>

<pre><code>## [1] 55
</code></pre>

<pre><code class="r">sapply(1:20, fib)
</code></pre>

<pre><code>##  [1]    1    1    2    3    5    8   13   21   34   55   89  144  233  377
## [15]  610  987 1597 2584 4181 6765
</code></pre>

<p>You may find that the calculation wastes a lot of resources. Advanced R[<a href="http://adv-r.had.co.nz/Function-operators.html">http://adv-r.had.co.nz/Function-operators.html</a>] mentions a function called <code>memoise()</code> to memorise the outputs. A memoised function can run much faster because it stores all of the previous inputs and outputs, using more memory.</p>

<pre><code class="r">system.time(fib(23))
</code></pre>

<pre><code>##    user  system elapsed 
##    0.20    0.00    0.21
</code></pre>

<pre><code class="r">system.time(fib(24))
</code></pre>

<pre><code>##    user  system elapsed 
##    0.33    0.00    0.33
</code></pre>

<pre><code class="r">library(memoise)
</code></pre>

<pre><code>## Warning: package &#39;memoise&#39; was built under R version 3.1.2
</code></pre>

<pre><code class="r">fib2 &lt;- memoise(function(n) {
  if (n &lt; 2) return(1)
  fib2(n - 2) + fib2(n - 1)
})
system.time(fib2(23))
</code></pre>

<pre><code>##    user  system elapsed 
##    0.00    0.00    0.03
</code></pre>

<pre><code class="r">system.time(fib2(24))
</code></pre>

<pre><code>##    user  system elapsed 
##       0       0       0
</code></pre>

<p>Still, we want to show another way deal with this issue.</p>

<pre><code class="r">fib_1 &lt;- 1
fib_2 &lt;- 1

sapply(1:50, function(i){
  fib &lt;- fib_1 + fib_2
  fib_2 &lt;&lt;- fib_1
  fib_1 &lt;&lt;- fib

  return(fib)
})
</code></pre>

<pre><code>##  [1] 2.000e+00 3.000e+00 5.000e+00 8.000e+00 1.300e+01 2.100e+01 3.400e+01
##  [8] 5.500e+01 8.900e+01 1.440e+02 2.330e+02 3.770e+02 6.100e+02 9.870e+02
## [15] 1.597e+03 2.584e+03 4.181e+03 6.765e+03 1.095e+04 1.771e+04 2.866e+04
## [22] 4.637e+04 7.502e+04 1.214e+05 1.964e+05 3.178e+05 5.142e+05 8.320e+05
## [29] 1.346e+06 2.178e+06 3.525e+06 5.703e+06 9.227e+06 1.493e+07 2.416e+07
## [36] 3.909e+07 6.325e+07 1.023e+08 1.656e+08 2.679e+08 4.335e+08 7.014e+08
## [43] 1.135e+09 1.836e+09 2.971e+09 4.808e+09 7.779e+09 1.259e+10 2.037e+10
## [50] 3.295e+10
</code></pre>

<p><code>&lt;&lt;-</code> allows you to get out of the scope within a function. </p>

<h3>Discrete Markov Chain Simulation</h3>

<p>Consider a discrete state transition stochastic process:</p>

<pre><code class="r">trans.mat &lt;- matrix(0, 3, 3)
trans.mat[1, ] &lt;- c(0.1, 0.3, 0.6)
trans.mat[2, ] &lt;- c(0.3, 0.4, 0.3)
trans.mat[3, ] &lt;- c(0.4, 0.6, 0)
trans.mat
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]  0.1  0.3  0.6
## [2,]  0.3  0.4  0.3
## [3,]  0.4  0.6  0.0
</code></pre>

<p>How to simulate this process?</p>

<p>(Roulette Wheel Method in Probability Simulation)</p>

<pre><code class="r">cum.trans.mat &lt;- t( apply(trans.mat, MARGIN=1, cumsum) )
cum.trans.mat
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]  0.1  0.4    1
## [2,]  0.3  0.7    1
## [3,]  0.4  1.0    1
</code></pre>

<pre><code class="r">state &lt;- 2
sim &lt;- c(state)

for( i in 2:1000 ){

  if( state == 1 ){
    rand &lt;- runif(1)
    state &lt;- ifelse(rand &lt;= cum.trans.mat[1, 1], 1, 
                    ifelse(rand &lt;= cum.trans.mat[1, 2], 2, 3) )
    sim[i] &lt;- state
  } else if ( state == 2 ){
    rand &lt;- runif(1)
    state &lt;- ifelse(rand &lt;= cum.trans.mat[2, 1], 1, 
                    ifelse(rand &lt;= cum.trans.mat[2, 2], 2, 3) )
    sim[i] &lt;- state
  } else if ( state == 3 ){
    rand &lt;- runif(1)
    state &lt;- ifelse(rand &lt;= cum.trans.mat[3, 1], 1, 
                    ifelse(rand &lt;= cum.trans.mat[3, 2], 2, 3) )
    sim[i] &lt;- state
  }

}
</code></pre>

<p>We can also simplify the codes. Think about why it works, and why <code>break</code> is needed in this code.</p>

<pre><code class="r">for( i in 2:1000 ){  
  for( j in 1:3 ){
    if( state == j ){
      rand &lt;- runif(1)
      state &lt;- ifelse(rand &lt;= cum.trans.mat[j, 1], 1, 
                      ifelse(rand &lt;= cum.trans.mat[j, 2], 2, 3) )
      sim[i] &lt;- state
      break
    }
  }
}
</code></pre>

<p>If there is no <code>break</code>, when <code>state == 1</code> is satisfied, the inner loop will be continued, <code>j</code> will be set to <code>2</code>, and the R will test <code>state == 2</code>. However, we have already changed variable <code>state</code> at this time. </p>

<p>Test if the simulation is consistency with the given matrix.</p>

<pre><code class="r">test &lt;- table( sim[1:999], sim[2:1000] )
test
</code></pre>

<pre><code>##    
##       1   2   3
##   1  24  87 166
##   2 122 162 136
##   3 131 171   0
</code></pre>

<pre><code class="r">test/rowSums(test)
</code></pre>

<pre><code>##    
##           1       2       3
##   1 0.08664 0.31408 0.59928
##   2 0.29048 0.38571 0.32381
##   3 0.43377 0.56623 0.00000
</code></pre>

<pre><code class="r">trans.mat
</code></pre>

<pre><code>##      [,1] [,2] [,3]
## [1,]  0.1  0.3  0.6
## [2,]  0.3  0.4  0.3
## [3,]  0.4  0.6  0.0
</code></pre>

<h3>Basic Option Pricing Models</h3>

<h4>Black-Scholes Option Pricing Model</h4>

<p>In BS model, the price of a option is given by:</p>

<p>\( C=S\times N(-d_1) - K\times e^{T-t_0}\times N(d_2) \)
\( P=K\times e^{T-t_0}\times N(-d_2)-S\times N(-d_1) \)</p>

<p>Where \( T \) is the a future time point, \( t_0 \) is right now. \( S \)  is the price of underlying asset, and \( K \) is executive price of the option. </p>

<pre><code class="r">S &lt;- 50
K &lt;- 52
r &lt;- 0.01
sigma &lt;- 0.5
Time &lt;- 0.25
t0 &lt;- 0

d1 &lt;- ( log(S/K) + (r+sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )
d2 &lt;- ( log(S/K) + (r-sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )

C &lt;- S*pnorm(d1) - K*exp(-r*(Time-t0))*pnorm(d2)
P &lt;- K*exp(-r*(Time-t0))*pnorm(-d2) - S*pnorm(-d1)  

c(C, P)
</code></pre>

<pre><code>## [1] 4.186 6.056
</code></pre>

<p>How to make the codes reusable? Notice both \( C \) and \( P \) are functions of parameters \( S \), \( T \), \( t_0 \), \( \sigma \) and \( r \). </p>

<p>\( C=F_c(S, T, t_0, \sigma, r) \)
\( P=F_p(S, T, t_0, \sigma, r) \)</p>

<p>Using them as arguments, we can write two functions to calculate the theoretical price.</p>

<pre><code class="r">bs.eurocall &lt;- function(S, K, r, sigma, Time, t0){
  d1 &lt;- ( log(S/K) + (r+sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )
  d2 &lt;- ( log(S/K) + (r-sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )

  eurocall &lt;- S*pnorm(d1) - K*exp(-r*(Time-t0))*pnorm(d2)

  return(eurocall)  
}

bs.eurocall(50, 52, 0.01, 0.5, 0.25, 0)
</code></pre>

<pre><code>## [1] 4.186
</code></pre>

<pre><code class="r">bs.europut &lt;- function(S, K, r, sigma, Time, t0){
  d1 &lt;- ( log(S/K) + (r+sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )
  d2 &lt;- ( log(S/K) + (r-sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )

  europut &lt;- K*exp(-r*(Time-t0))*pnorm(-d2) - S*pnorm(-d1)  

  return(europut)  
}

bs.europut(50, 52, 0.01, 0.5, 0.25, 0)
</code></pre>

<pre><code>## [1] 6.056
</code></pre>

<p>Notice these these two functions are quite similar with each other. We can add an argument called &ldquo;type&rdquo; to control what kind of option is going to be calculated.</p>

<pre><code class="r">bs.optprc &lt;- function(type, S, K, r, sigma, Time, t0){
  d1 &lt;- ( log(S/K) + (r+sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )
  d2 &lt;- ( log(S/K) + (r-sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )

  if(type == &quot;euro.call&quot;) optprc &lt;- S*pnorm(d1) - K*exp(-r*(Time-t0))*pnorm(d2)
  if(type == &quot;euro.put&quot;)  optprc &lt;- K*exp(-r*(Time-t0))*pnorm(-d2) - S*pnorm(-d1)  

  return(optprc)  
}

bs.optprc(type=&quot;euro.call&quot;, 50, 52, 0.01, 0.5, 0.25, 0)
</code></pre>

<pre><code>## [1] 4.186
</code></pre>

<h4>Binomial Tree Model</h4>

<p>Binomial tree model is another famous option pricing model. This model assumes the price of the uderlying asset will go up or go down in a certain rate during every single period of time. We can calculate the change rate of price, and the probability to go up. </p>

<p>The final price of the option is introduced firstly, and then we can trace back to the original price and get the theoretical price right now.</p>

<pre><code class="r">binom.optprc &lt;- function(type, S, K, r, sigma, Time, N){

  dt &lt;- Time/N

  u &lt;- exp(sigma*sqrt(dt))
  d &lt;- 1/u
  p &lt;- (exp(r*dt)-d)/(u-d)

  tree &lt;- matrix(0, nrow=N+1, ncol=N+1)

  for( y in 0:N ){
    if( type==&#39;call&#39; )  tree[y+1, N+1] &lt;- max(0, S*(u^y)*(d^(N-y))-K )     
    if( type==&#39;put&#39;  )  tree[y+1, N+1] &lt;- max(0, K - S*(u^y)*(d^(N-y)) )   
  }

  for( x in seq(from=N, to=1, by=-1) ){
    for( y in seq(from=1, to=x, by=1) ){
      if( type==&#39;call&#39; ) tree[y, x] &lt;- exp(-r*dt)*(p*tree[y+1, x+1] + (1-p)*tree[y, x+1]) 
      if( type==&#39;put&#39;  ) tree[y, x] &lt;- exp(-r*dt)*(p*tree[y+1, x+1] + (1-p)*tree[y, x+1])   
    }
  }

  optprc &lt;- tree[1, 1]

  return(optprc)
}

binom.optprc(type=&#39;call&#39;, S=50, K=52, r=0.01, sigma=0.5, Time=0.25, N=30)
</code></pre>

<pre><code>## [1] 4.225
</code></pre>

<pre><code class="r">binom.optprc(type=&#39;put&#39;, S=50, K=52, r=0.01, sigma=0.5, Time=0.25, N=30)
</code></pre>

<pre><code>## [1] 6.095
</code></pre>

<h3>Split-Apply-Combine Strategy in Data Manipulation</h3>

<p>(This example comes from: Data Manipulation, Chapter 3.)</p>

<p>Split-apply-combine strategy is quite often used in data analysis. </p>

<ul>
<li>Split: Split the data into different groups</li>
<li>Apply: Apply your function to finish your analysis within each group</li>
<li>Combine: Combine the result of each group</li>
</ul>

<p>We will use data set <code>iris</code> (which is an example data set already exists in R) as an example. We want to know the first four variables&#39; mean of each kind of species.</p>

<pre><code class="r">head(iris)
</code></pre>

<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa
</code></pre>

<h4>Without a loop</h4>

<p>We can split the data into three different data sets and calculate the mean one by one, and then combine them together.</p>

<pre><code class="r">## Split
iris.set &lt;- iris[iris$Species == &quot;setosa&quot;, -5]
iris.versi &lt;- iris[iris$Species == &quot;versicolor&quot;, -5]
iris.virg &lt;- iris[iris$Species == &quot;virginica&quot;, -5]

## Apply
mean.set &lt;- colMeans(iris.set)
mean.versi &lt;- colMeans(iris.versi)
mean.virg &lt;- colMeans(iris.virg)

## Combine
mean.iris &lt;- rbind(mean.set, mean.versi, mean.virg)
rownames(mean.iris) &lt;- c(&quot;setosa&quot;, &quot;versicolor&quot;, &quot;virginica&quot;)

mean.iris
</code></pre>

<pre><code>##            Sepal.Length Sepal.Width Petal.Length Petal.Width
## setosa            5.006       3.428        1.462       0.246
## versicolor        5.936       2.770        4.260       1.326
## virginica         6.588       2.974        5.552       2.026
</code></pre>

<h4>With a loop</h4>

<p>Fortunately, there are just three kinds of folowers in this dataset. What if there are 100 groups to calculate? </p>

<pre><code class="r">mean.iris.loop &lt;- NULL
for( species in unique(iris$Species) ){
  iris_sub &lt;- iris[iris$Species==species]
  col_means &lt;- colMeans(iris_sub[, -5])
  mean.iris.loop &lt;- rbind(mean.iris.loop, col_means)  # this way is not recommended
}

rownames(mean.iris.loop) &lt;- unique(iris$Species)

mean.iris.loop
</code></pre>

<h4>More Convenient Method</h4>

<p>Atually, there still exists more convenient ways. Here we recommend you to read the following materials and get familiar with package <code>plyr</code>:</p>

<ul>
<li>The Split-Apply-Combine Strategy for Data Analysis, Hadley Wickham, 2011.</li>
<li>Data Manipulation, Jaynal Albedin, Chapter 3.</li>
</ul>

<pre><code class="r">library(plyr)
ddply(iris, .variables = &quot;Species&quot;, .fun = function(df.sub){
  colMeans(df.sub[, -5])
})
</code></pre>

<pre><code>##      Species Sepal.Length Sepal.Width Petal.Length Petal.Width
## 1     setosa        5.006       3.428        1.462       0.246
## 2 versicolor        5.936       2.770        4.260       1.326
## 3  virginica        6.588       2.974        5.552       2.026
</code></pre>

</body>

</html>

